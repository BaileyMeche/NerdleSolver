# -*- coding: utf-8 -*-
"""NerdleSolver_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UmeT3Q_HsIf1sAQUTlNZZC5SWXbb3Pkj
"""

from flask import Flask, request, jsonify
from typing import Union, Tuple
from dataclasses import dataclass
import time
import pandas as pd
from itertools import product
import csv

app = Flask(__name__)

#Read in from txt file
with open('equations.txt', 'r') as file:
    reader = csv.reader(file)
    recovered_data = [tuple(row) for row in reader]

solutions_matrix = pd.DataFrame(recovered_data, columns=['t0','t1', 't2', 't3', 't4', 't5', 't6', 't7'])

# Define a custom type for the elements which can be either an integer or a string for operators
TileElement = Union[int, str]

@dataclass
class GreenTiles:
    tiles: Tuple[TileElement, TileElement, TileElement, TileElement, TileElement, TileElement, TileElement, TileElement]
    index_char_dict = lambda tiles: {index: char for index, char in enumerate(tiles.tiles) if char is not None}

@dataclass
class PurpleTiles:
    tiles: Tuple[TileElement, TileElement, TileElement, TileElement, TileElement, TileElement, TileElement, TileElement]
    index_char_dict = lambda tiles: {index: char for index, char in enumerate(tiles.tiles) if char is not None}

@dataclass
class BlackTiles:
    tiles: Tuple[TileElement, TileElement, TileElement, TileElement, TileElement, TileElement, TileElement, TileElement]
    index_char_dict = lambda tiles: {index: char for index, char in enumerate(tiles.tiles) if char is not None}

def filter_dataframe(df, Green, Purple, Black):
  """
  Filters the DataFrame based on inclusion and exclusion criteria.

  Args:
  - df (pd.DataFrame): The DataFrame to filter.
  - include_criteria (dict): Criteria where the key is the column name and the value is the value to match.
  - exclude_criteria (dict): Criteria where the key is the column name and the value is the value to not match.

  Returns:
  - pd.DataFrame: The filtered DataFrame.
  """
  # Start with the full DataFrame
  filtered_df = df.copy()

    # Apply inclusion criteria
  #  for k,v in PurpleTiles.index_char_dict(Purple).items():
  for column, value in GreenTiles.index_char_dict(Green).items():
    column = 't'+ str(column)
    filtered_df = filtered_df[filtered_df[column] == value]

  # Apply exclusion criteria
  for column, value in BlackTiles.index_char_dict(Black).items():
    column = 't'+ str(column)
    filtered_df = filtered_df[filtered_df[column] != value]

  for column, value in PurpleTiles.index_char_dict(Purple).items():
    # Filter for rows where the value exists anywhere except in the specified column
    column = 't'+ str(column)
    filtered_df = filtered_df[(filtered_df != value).any(axis=1) & (filtered_df[column] != value)]

  return filtered_df

"""## Flask logic"""

@app.route('/solve', methods=['POST'])
def solve():
    # Extract data from POST request
    input_data = request.get_json()
    print("Received data:", input_data)

    # Assume you have a function `process_data` that takes the input data
    result = process_data(input_data)

    return jsonify(result)

def process_data(data):
    # Extract data for each tile type
    green_tiles = GreenTiles(tuple(data.get('green')))
    purple_tiles = PurpleTiles(tuple(data.get('purple')))
    black_tiles = BlackTiles(tuple(data.get('black')))

    # Here, plug the data into whatever processing functions you have
    # For example:
    filtered_results = filter_dataframe(solutions_matrix, green_tiles, purple_tiles, black_tiles)
    return filtered_results.to_json(orient='records')

if __name__ == "__main__":
    app.run(debug=True)